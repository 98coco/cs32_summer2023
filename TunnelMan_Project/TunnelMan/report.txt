//StudentWorld 
For my student world class, the functions I made public were init, move, cleanUp, digEarth(int x, int y), checkEarth(int x, int y), outerBoundaries(int x, int y), getGameObjVec, addObjToVec(GameObjects *objs), getTunnelManPtr, getEarthArr(int x, int y), studentsetOil(int L), and setSonarField. For init, move, and cleanUp, I made these functions public because another class calls them the GameWorld class. I initialized all my game objects (earth, gold, oil, sonar, etc.) in my init function. I created other private functions within this function to help me initialize all the objects. For instance, I used fillWholeEarth, createMineShaft, and makeTopEmpty to make my field. For my move function, since this is used to play the game, I used it to set the number of protestors and goodies during each tick. I also used it to state what happens to the game when the player dies and still has lives, dies and has no lives, and when a player finishes the level. For my cleanup function, I used it to destroy everything (it is similar to a destructor, but not the actual destructor). To store my earth, I used a 2D array to store my earth pointers that point to an earth object. I used a 2D array because it allowed me to access coordinates in functions like my dig earth function quickly. The purpose of my digEarth function is to get a coordinate and clear the earth. I made this function public because I called it in my actor cpp file every time I wanted to get the TunnelMan to digEarth and when I initialized a boulder. Furthermore, I also call this function for when I generate waterpools (a bug in my program). This is because I ran out of time trying to figure out how to have water not generated on earth objects. If I left it alone without the earth object, the water would be barely noticeable. I have a public checkEarth function because it allowed me to identify in my boulder class whether or not there was earth below my boulder. This function returned me a boolean value that allowed for mean to quickly use this in an if statement. For my outerBoundaries function, I had this return whether or not the coordinates were out of bounds. If the coordinates were out of bunds, it will return false. If it weren’t, it would return true. I made this function public because I used it in classes like my tunnel man cpp so that the person does not go out of bounds. The accessors, getters, and additions I have in the class that are public are my getGameObjVec, addObjToVec, getTunnelManPtr, getEarthArr, studentSetOil, setSonarField, and earthAndBoulder. For getGameObjVec, it returns my private member vector of game object pointers that I used to store my game object pointers. With this function, I can access objects in the game when I want to make a specific implementation. For instance, when I want to check if the TunnelMan is within the radius of a gold object. I use this function to iterate through my vector to find the coordinates of a gold object and compare those coordinates to the tunnelman. For my addObjToVec, I created this function in case I wanted to add a new actor to my vector. By having this function, I am allowed to add actors during gameplay. For instance, in the Tunnelman’s class, I have a private function called TunnelManSquirts that uses this addObjToVec function to create new squirt objects when the player presses a key. By having this function, I can pass it along to the student world that is controlling our game. For my getTunnelManPtr, I use it to give me the address of the tunnelman in our game. I would call this function whenever I wanted the tunnel man’s coordinates, check the inventory of the tunnel man, etc. For my getEarthArr, I have this as a public function to use in my object classes to see whether or not the earth at that coordinate is alive or dead. I used this function in my boulder class to manage the various states the boulder is in, such as when it is falling (if it sees an earth, it should stop falling, and the boulder should become dead). For my setSonarField function, I use this to keep track of how many sonar can be on the field at once. I specifically use this function when the tunnelman finds the sonar in the area. Once the tunnelman finds the sonar, the sonar class uses this function to set the sonar on the field to 0 so that we can generate another sonar when given the chance. 


For this class, I tested the boundaries by seeing whether or not the object would move off the grid. I also printed out various statements to see whether the constructor would initialize again, whether or not the number expected for protestors was correct, and whether or not a validating function gave me my desired bool result, such as if earthOrBoulder worked if I passed in a particular x and y coordinate to it. Additionally, I checked the size of my vector whenever I added a sonar and water pool to the tick to ensure it was correctly pushing everything back during a chance. I also tested the move() function by repeatedly killing the tunnel man to ensure I decremented the lives it has left before dying, that the tunnel man can level up, and that the tunnel man completely loses the game if it has no more lives left. 


//GameObjects
My GameObjects class is the class that will serve as the main base class for all my objects. The public functions I have in this class are a pure virtual destructor, pure virtual void doSomething, setAliveState, getAliveState, withinRadius, getTypeOfObj, ticksCountdown, setTicksForCountdown, getTicksPassed, annoyMe, getHealth,setHealth,setSound, and getSound. When using inheritance and polymorphism, we must use pure virtual destructors to ensure we properly destroy items, or else an undefined behavior can occur. Each class will have to write its destructor so this behavior does not happen, and by making it a pvf, we can ensure that everything gets destructed properly.  The doSomething function is a pvf because all classes derived from this gameObject class must define its doSomething method that the student world class can call and use to play the game for all the actors. Having it be a pvf ensure that each class does so. In this class, I also have a getAliveState and setAliveState function. These functions are public so that we can check the alive status of each object so that we can use this to set things to visible, see whether or not we can use the object when we iterate through the vector, etc. Furthermore, if I included this as its own function for all the derived classes, then that would be repeated code because this function does the same thing all the time. For the withinRadius function, this function checks the Euclidian distance of each object. For instance, when generating objects in the oil field, each object must be within a radius of 6 away from each other (although in my implementation, there is currently a bug with this part of my code at times because of the boundaries I set that I did not have enough time to look through thoroughly). I also use this function when implementing when the protestor should shout at the tunnel man, how far from the protestor a tunnel man can be when he wants to squirt water at the protestor and make the protestor annoyed, etc. My next public function is a pvf called getTypeOfObj. This function allows me to differentiate between the objects in our game objects vector when I want a behavior to only occur for a specific object. For instance, when creating the gold class, I had to decipher between a regular protestor and a hardcore protestor since the points the player gets are different based on the protestor picking up the gold they dropped. I made getTypeOfObj a pvf because I wanted all objects to return the object they are, which I used a global enum for. The next set of public functions in this class are ticksCountdown, setTicksForCountDown, and getTicksPassed. These functions are used to keep track of the ticks that pass. I specifically put these functions here because each time the move() function is called, one tick passes, and our move function is the one that always calls the do something. In most of these game object classes, we were specified to count the ticks because an object can do something. For example, when the boulder was in a waiting state, it had to wait 30 ticks before it could start falling, and in my protestors class I had to keep track of the ticks for when the protestor hadn't yelled at the tunnelman and it was within a radius of 4. Having these three functions allows me to count these ticks. Another function I made was the annoyMe function. I made this function public, eventhough the only objects that can be annoyed are tunnel man and the protestors, because some classes like the boulder and squirt class need to somehow annoy these people when they are within a radius of these people. This function decrements the health points of these people. Next, I have my health getters and setters. These allow me to check how many health points a person has and to decrease the health points when tunnel man or protestors get annoyed. The last two public functions I have in the class are setSound and getSound. I used these functions to signify when a sound should be played because if I didn’t, I kept encountering the problem where the sounds kept playing repeatedly. 


To test this class, I printed out statements to ensure that each function was doing the right thing for where it was called. For instance, whenever the annoyMe function was used, I made sure to print out the health points of the tunnelMan before and after the annoyMe function. That way, I knew it was decreasing the health points of the tunnelMan correctly. To also check the tick countdown function, I random set a tick to a number and printed out the tick member variable to see if the tick variable was decrementing the way I wanted it to and whether it brought me to an if statement that required the tick to be 0 for it to execute the body (e.g. if protestor hasn’t yelled at the tunnel man for 15 ticks and they are within a radius of each other. I initially set the tick count to 15, and it will continue decrementing unless it gets reset because the tunnelman was near. Otherwise, if it fully reaches 0, check the former).


//Earth
For my earth class, I created a doSomething so that the move() function could call it and so that it becomes a concrete class that we can instantiate. I also included the getTypeOfObj here for the same reason. To test this class, I ensured all pointers were initialized and only set to false if it died instead of deleting. I checked the alive status of each earth using a nested for loop to check its alive status. 


//TunnelMan
For my tunnelman class, I have a series of setters and getters: setWaterSquirt, getWaterSquirt,setGold,getGold, and setSonar. I made these functions public specifically for the reason that I need to access the inventory of the tunnelamn for the display text. Additionally, at some points in the game, such as when the tunnel man drops a gold, fires a squirt, or uses a sonar kit, I had to update the amount it had left so that if the tunnel man wanted to perform the same action again, it had to make sure it had enough inventory. I also created a tunnelManDirectSquirts function that the squirts class calls to check to see if a squirt can move in a specific direction. 


To test the tunnel man, I tested to ensure that the tunnel man never went out of bounds. Furthermore, it performed the correct actions if I pressed a specific key (e.g. if I pressed a tab, it dropped a gold; if I pressed space, it squirted water; if I pressed down, it went down, etc.). To test the tunnel man, I also ensured that it could only move in a specific direction by checking that location first to validate that it would not move out of bounds.


//Protestors
For my protestors class, this class was created to combine all the functionality of the protestors since they were mostly the same.  That way, I would not have to repeat the same code for hardcore and regular protestors.  In the class, my public functions are moveBackAndForth, getRestingState, setRestingState, getYellTick,setYellTick, and do Something. All these functions are public because the two protestors use these functions and inherit them. I ran out of time for this project, so I could not successfully finish both the regular protestor and hardcore protestor classes. Therefore, that is why I just have the protestors move back and forth on the top row for the frame and why they share one doSomething. The getRestingState and setResting state are used so that the protestors would slow down and not doSomething every tick.  getYellTick and setYellTick are used to countdown the ticks so the protestors can yell again. 


To test what I have done for this class, I checked to ensure the protestor never went out of bounds. Additionally, if the tunnel man was nearby, I had to check whether or not the protestor would yell at the tunnel man. If it didn’t, I printed our various statements to see where my logic was going wrong or where in the if-else statements it was not entering when it was supposed to. Furthermore, I made sure the protestor could die from a squirt by having the tunnel man repeatedly hit it until it gave up.


//Items, gold, barrelofoil, water, sonar, squirt 
I have an items class that is a base class of all goodies. I specifically made this a base class because all goodies have a thing in common: they can be picked up by the tunnelman and used for his inventory. It was also more easy for me to visualize in my head if I separated the goodies from everything else. For this class, I have three public functions that get whether the item can be picked up by the tunnelman and the type of state they're in (temporary or permanent). These functions allow me to know whether or not I would have needed to set up a tick counter for them and when to set the visibility if they can be picked up by the tunnel man. For my gold, barrel of oil, water, boulder, squirt, and sonar classes, I did not create any new public functions. I just completed the functions that were necessary to make these classes a concrete class.


To test the gold class, I had to ensure that all the gold that was in a permanent state stayed in its location for the entirety of the level. To test this, I just made a permanent gold set visible when it was created instead of being buried under the earth. Furthermore, I also tested the state of a temporary gold by having the tunnel man drop gold and leave it there until it disappeared. I also tested what would occur if I place the gold within a radius of the protestor to see if the protestor would pick it up. 


To test the barrel of oil class, I made sure that it stayed within the oil field throughout the entirety of the game. I also printed out statements that allowed me to check how many barrels of oil there was left and that when a barrel was picked up, the amount on the field was being kept track in the student world was decreased. I made the tunnel man pick up all the oil, to ensure that the player leveled up after collecting all the barrels of oil and the number of oil in the oil field was 0. I also tested to see if the barrel of oil would show up if the tunnel man was within radius of it. I would have the tunnelman keep digging up the earth until it saw an oil barrel pop up before collecting (I also did the same with the permanent gold). 


To test my water class, I used my tick counter to make sure that all water would leave the field after a certain amount of ticks. I also made sure that the water added 5 new squirts to the tunnel man inventory by printing out statements of the tunnel man’s inventory before and after picking up a water.  Like mentioned before, I was not able to successfully get the water to be distributed accurately where there was no earth. Water pools still generate on-earth pieces.

To test the sonar kit, I first made sure that only one was place on the field every time a sonar could be on the oil field. Additionally, I made sure that the sonar kit was updated in the tunnelman’s inventory when it was picked up by printing out if statements. When I wanted to check the functionality of the sonar kit, I would use the kit I had and see how far from the tunnelman it made the objects visible. At some point in trying to make sure that the objects showed up when the sonar kit was used, the sonar kit was not accurately keeping track of the inventory, but I was able to fix it with print statements. 


To test the boulder class, I had to make the tunnel man dig the earth below it to make sure it falls until it hits another earth or the tunnelman (not the protestor because I could not get the functionality to work). Another test I did was making sure that even if there was half the earth below the boulder, it maintained staying in its stable state. I also tested to make sure that the if it were to have all the earth below it clear (so until the end of the grid) it still fell and not cause an accessing error. It just disappeared near the bottom (setVisible(false)). I also tested to make sure that two boulders that landed on each other just disappeared.


To test the squirt class, I initially fired the squirts if there were no obstacles to make sure it was covering the distance I wanted. Moreover, if there was an earth or boulder right in front of the tunnelman, I ensure that the tunnelman could not fire a squirt (I made this assumption because the spec did not really explain what happens if the player fired a squirt at an earth or boulder at this position). I also tested to make sure that the squirt did not go the full length it could if the distance between the squirt and the earth(or boulder) was less than what the full distance was.